use std::io::Read;
use std::str::FromStr;

use flate2::read::GzDecoder;
use tide::http::headers::HeaderValue;
use tide::{Request, Response, Result};

fn gunzip(src: &[u8]) -> Vec<u8> {
    let mut dst = Vec::new();
    GzDecoder::new(src).read_to_end(&mut dst).unwrap();
    dst
}

/// Serve a byte slice containing gzipped data
///
/// Handle clients that do not support compression by decompressing
/// content on the fly.
/// Handle caching using ETags generated at build time.
///
/// This function is used by the code generated in build.rs
fn response(req: &Request<()>, etag: &str, mime: &str, body_gzipped: &[u8]) -> Result<Response> {
    let etag_matches = req
        .header("If-None-Match")
        .map(|etags| etags.contains(&HeaderValue::from_str(etag).unwrap()))
        .unwrap_or(false);

    let accept_gzip = req
        .header("Accept-Encoding")
        .map(|hdr_lines| {
            hdr_lines
                .iter()
                .flat_map(|hdr_line| hdr_line.as_str().split(","))
                .any(|encoding| encoding.trim().eq_ignore_ascii_case(&"gzip"))
        })
        .unwrap_or(false);

    let res = match (etag_matches, accept_gzip) {
        (true, _) => Response::new(304),
        (false, true) => Response::builder(200)
            .content_type(mime)
            .header("Content-Encoding", "gzip")
            .header("ETag", etag)
            .body(body_gzipped)
            .build(),
        (false, false) => Response::builder(200)
            .content_type(mime)
            .header("ETag", etag)
            .body(gunzip(body_gzipped))
            .build(),
    };

    Ok(res)
}

pub(super) fn register(server: &mut tide::Server<()>) {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/static_files.rs.in"));
}
