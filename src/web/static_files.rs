// This file is part of tacd, the LXA TAC system daemon
// Copyright (C) 2022 Pengutronix e.K.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use std::io::Read;
use std::str::FromStr;

use flate2::read::GzDecoder;
use tide::http::headers::HeaderValue;
use tide::{Request, Response, Result};

fn gunzip(src: &[u8]) -> Vec<u8> {
    let mut dst = Vec::new();
    GzDecoder::new(src).read_to_end(&mut dst).unwrap();
    dst
}

/// Serve a byte slice containing gzipped data
///
/// Handle clients that do not support compression by decompressing
/// content on the fly.
/// Handle caching using ETags generated at build time.
///
/// This function is used by the code generated in build.rs
fn response(req: &Request<()>, etag: &str, mime: &str, body_gzipped: &[u8]) -> Result<Response> {
    let etag_matches = req
        .header("If-None-Match")
        .map(|etags| etags.contains(&HeaderValue::from_str(etag).unwrap()))
        .unwrap_or(false);

    let accept_gzip = req
        .header("Accept-Encoding")
        .map(|hdr_lines| {
            hdr_lines
                .iter()
                .flat_map(|hdr_line| hdr_line.as_str().split(","))
                .any(|encoding| encoding.trim().eq_ignore_ascii_case(&"gzip"))
        })
        .unwrap_or(false);

    let res = match (etag_matches, accept_gzip) {
        (true, _) => Response::builder(304)
            .header("Vary", "Accept-Encoding")
            .build(),
        (false, true) => Response::builder(200)
            .content_type(mime)
            .header("Content-Encoding", "gzip")
            .header("Vary", "Accept-Encoding")
            .header("ETag", etag)
            .body(body_gzipped)
            .build(),
        (false, false) => Response::builder(200)
            .content_type(mime)
            .header("ETag", etag)
            .header("Vary", "Accept-Encoding")
            .body(gunzip(body_gzipped))
            .build(),
    };

    Ok(res)
}

pub(super) fn register(server: &mut tide::Server<()>) {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/static_files.rs.in"));
}
